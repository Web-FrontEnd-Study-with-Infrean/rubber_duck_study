# 브라우저 렌더링과 성능 개선

## 브라우저 렌더링
브라우저를 열면 가장먼저 주소창에 사람이 읽을 수 있는 텍스트로 된 도메인 이름이 입력됩니다. 이 도메인은 DNS(Domain Name System) 을 통해 기계가 읽을 수 있는 IP 주소로 변환됩니다. 이 IP 주소는 흔히 집주소에 비유가 되며 고유한 주소입니다. 문자열로된 주소가 IP 주소로 반환되어지는데까지는 몇가지 단계를 거쳐야하고 IP 주소를 반환받아 웹 서버에 리소스 요청을 진행합니다.
  
브라우저에는 렌더링 엔진이 존재하고 이 렌더링 엔진의 역할은 요청받은 내용을 화면에 표시하는 역할을 합니다. 리소스를 전달받아 화면에 표시하기까지 몇단계의 동작과정을 거치게되는데 우선 HTML 문서를 파싱하고 태그를 DOM 노드로 변환합니다. 
  
이후 CSS 파일과 스타일 요소도 파싱후 두 트리가 결합하면서 렌더트리를 생성합니다. 렌더트리가 생성되는 과정에서 화면에 표시되지않는 부분은 렌더트리에도 생성되지않습니다. 렌더트리가 생성되면 레이아웃과정이란 계산을 통해 사이즈와 컨테츠가 보여질 위치가 정해지게됩니다. 
  
이후 화면에 그려지고 보여지는 과정이 진행되면 실제로 사용자가 화면을 볼 수 있게 됩니다.


## Critical Rendering Path

## 성능 개선

## 참고 자료
- [Critical Rendering Path](https://developers.google.com/web/fundamentals/performance/critical-rendering-path)
- [Naver D2](https://d2.naver.com/helloworld/59361)
- [TOAST UI](https://ui.toast.com/fe-guide/ko_PERFORMANCE)
- [AWS DNS](https://aws.amazon.com/ko/route53/what-is-dns/)
- [NAVER D2 하드웨어 가속](https://d2.naver.com/helloworld/2061385)

<!-- ## 브라우저의 렌더링과 성능개선
우선 여기서 제가 설명하는 브라우저는 크롬브라우저 기준으로 V8 엔진을 위주로 설명하겠습니다. 

우리가 웹 개발을 했을때 화면에 우리가 작성한 코드가 디자인된 화면으로 보여지는건 브라우저라는 소프트웨어를 통해서 가능합니다. 이 브라우저에는 크게 두가지 엔진이 있는데 하난 html 과 css 를 파싱하고 돔트리형태로 만들어서 화면에 보여주는 렌더링 엔진과 자바스크립트를 해석하고 실행하는 엔진이 있습니다. 
  
브라우저는 주소입력창을 갖고있고 이 주소 입력창에 텍스트로 구성된 주소를 입력하게되면 DNS(도메인 네임 시스템)에 의해서 호스트 도메인 이름을 호스트의 네트워크 주소로 변경합니다. 즉 네트워크에서 해석가능한 IP 주소로 변경됩니다.
  
DNS 에서 IP 주소로 변환되는 과정도 사실 여러단계를 거쳐서 진행되게됩니다. 이 과정이 끝나고 나면 그때 비로소 브라우저가 변환된 IP 주소로 HTTP 요청을 보내고 서버가 해당 리소스들을 반환하게됩니다.  
[DNS => IP 변환 단계](https://www.cloudflare.com/ko-kr/learning/dns/what-is-dns/)
  
서버에서 리소스를 반환받게되면 브라우저는 전달받은 리소스들을 해석합니다. 가장먼저 html 을 다운받고 해석하며 파싱과정을 거치게되는데 이 파싱과정을 거치면서 DOM 트리가 구성됩니다. 파싱과정에서 `script`, `link`, `img` 를 만나게되면 파싱을 중단하고 해당 리소스들을 요청하고 다운로드 합니다.
  
파싱하는 과정에서는 인코딩되어 해석된 문자열을 토큰화를 시키고 개별 노드객체로 변환한뒤 돔을 구성하게됩니다. CSS 또한 파싱과정을 거쳐 트리형태로 구성되고 DOM 과 CSSOM 트리는 Attachment 라는 결합과정을 거쳐 렌더트리가 생성됩니다. 이때 브라우저의 렌더트리는 화면에 보여질것들로만 이루어 집니다. HTML 의 Head 태그나 meta 그리고 display: none 처리된 것들은 렌더트리에서 제외됩니다.
  
렌더 트리중 속성에 따라 필요한경우 렌더 레이어가 만들어지고 이 렌더 레이어중에서 GPU 처리부분이 있으면 그래픽레이어로 분리됩니다.   
- CSS 3D Transform, perspective 속성이 적용된경우
- video, canvas 요소
- CSS3 애니메이션함수 CSS 필터 함수

  
이렇게 결합을 통해 생성된 렌더트리로 레이아웃과정을 진행하는데 이 과정에서 노드의 정확한 위치와 크기를 계산하고 화면에 그릴 준비를 합니다. 노드의 정확한 크기와 위치를 알기위해 루트부터 노드를 순회하면서 계산합니다.
  
레이아웃 단계에서 계산된 값을 화면상의 실제 픽셀로 변환하는데 이때 사이즈나 위치와 관계없는 css 속성들을 적용하고 이 결과는 포토샵의 레이어처럼 개별 레이어로 관리됩니다. 이렇게 생성된 레이어들을 합셩하여 브라우저 스크린에 업데이트를 진행하게됩니다.
  
브라우저의 랜더링 과정은 한번만에 끝나는것이 아니라 언제든지 다시 발생할 수 있습니다. 이 과정에서 사이즈나 위치와 관련된 속성이 변경될경우 리플로우가 발생하고 이외에의 변경사항은 리페인트라고 합니다.

## 브라우저의 렌더링 성능 개선
일반적으로 스크린은 1초에 화면을 60번 그려낸다고 합니다. 이걸 60fps 라는 수치로 부를 수 있는데 브라우저또한 이 수치에 맞춰줘야 매끄럽게 페이지가 나올 수 있습니다. 1초에 60프레임을 그린다는걸 계산해보면 1개 프레임마다 약 0.016초가 걸린다고 볼 수 있습니다.
  
이렇게 브라우저가 하나의 화면을 그려내는 과정을 Critical Rendering Path 라고 합니다.
즉 처음 설명했던 렌더링 과정의 파싱을 통해 돔트리를 생성하고 화면에 페인트 하기까지의 과정을 크리티컬 렌더링 패스라고 부르고 이 과정의 시간을 최소화하는것을 크리티컬 렌더링 패스 최적화 라고 할 수 있습니다.
  
크리티컬 렌더링 패스 최적화를 하면 컨텐츠를 화면에 더 빨리 렌더링 할 수 있고 초기 렌더링 후 업데이트사이의 시간을 줄일 수 있습니다.
  
CSS 부터 얘기하자면 CSS 는 렌더링 차단 리소스로 취급됩니다. 무슨말이냐면 CSSOM 트리가 생성되기전까지 브라우저는 다른 렌더링을 중단합니다. HTML 도 렌더링 차단 리소스이지만 어차피 돔트리없이는 렌더링이 불가능하기때문에 그 기준이 명확하지만 CSS 는 다소 불명확할 수 있습니다. 
  
CSS 다운로드 최적화는 link 에 있는 속성중에 media 라는 속성을 활용할 수 있습니다. 이 속성을 사용하면 특정 상황에 사용할 CSS 를 지정할 수 있고 특정상황이 발생하지않으면 다운로드는 진행하지만 렌더링을 차단하지않습니다.
- print 프린트할때
- (min-width: 40em) 특정 넓이일때
- orientation:potrait 모바일에서 가로모드일때

자바스크립트는 돔생성 즉 파서를 차단하는 리소스입니다. 일반적인 하드코딩시 스크립트 선언은 바디태그내의 최하단에 위치시키거나 자바스크립트 코드내에 onload 같은 메소드를 사용하여 페이지 로드가 끝난다음에 스크립트가 실행되도록 했습니다.
  
자바스크립트는 브라우저내에 대부분의 컨텐츠를 직접 조작할 수 있습니다. 즉 자바스크립트로 돔을 어떻게 조작하느냐에 따라서 브라우저의 성능에 차이가 있을 수 있습니다.
  
보통 렌더링을 위한 리소스를 다운받고 화면에 그린다음 자바스크립트를 실행되도록하는데 이때 사용할 수 있는 메소드가 domContentLoaded, onload 두가지가 있습니다. 만약 html 에 이미지를 불러오는 소스가 있다고 가정했을때 domContentLoaded 는 이미지 리소스에 관계없이 렌더트리 구성이 끝나면 화면에 그려나가기 시작합니다. onload 는 이미지를 포함 모든 리소스가 다운로드가 되었을때 실행되는 메서드입니다.
  
즉 화면을 빨리 그려줘야한다라는 관점에서 봤을떄는 domContentLoaded 를 사용하는것이 맞고 완성된 전체 페이지를 보여주는것이 맞다 라고 봤을땐 onload 를 사용하는것이 맞는것같습니다.
  
주요리소스는 페이지의 초기 렌더링을 차단할 수 있는 리소스 입니다. 이러한 리소스가 적을수록 브라우저와 CPU 및 기타 리소스의 작업이 줄어듭니다.
  
파서 차단 자바스크립트는 DOM 및 CSSOM 을 조작할 수 있기때문에 CSSOM 가 처리될때까지 브라우저를 기다리게하고 DOM 생성을 중지합니다. 이는 최초 렌더링에 지연을 발생시킬 수 있습니다.

CSS 내에서 import 로 다른 CSS 를 가져와 사용하게되는것도 되도록 피하는것이 좋다고합니다. 만약 import 가 사용되었을경우 주요경로에 대한 추가왕복을 유도하기때문에 그만큼 자원의 시간을 잡아먹게 됩니다. -->