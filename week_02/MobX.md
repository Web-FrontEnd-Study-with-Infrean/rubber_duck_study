## MobX

몹엑스란 리액트에서 사용가능한 상태관리 라이브러입니다. 리액트는 기본적으로 단방향 데이터 바인딩 방식을 취하고있어 부모에서 자식으로의 데이터 흐름을 기본으로 합니다.

그리고 컴포넌트 개발방식이 가능한데 이 각각의 컴포넌트는 state 와 props 에 의해서 상태를 관리하고 변경할 수 있습니다.

단방향 데이터 전달 방식으로 컴포넌트 기반 개발을 진행하다보면 컴포넌트의 중첩이 많아질수록 특정상태는 뎁스가 깊어지는 경우가 발생합니다.

그리고 모든 상태나 비즈니스 로직을 컴포넌트 내부에서 처리하고 관리하다보면 컴포넌트의 내부는 매우 복잡해지고 무거워지게되는 문제점이 발생합니다.

이런 문제점을 해결하기위한 도구로서 몹엑스가 나오게 되었습니다. 몹엑스를 사용하면 데코레이터를 통해 비즈니스 로직을 깔끔하게 유지할 수 있고 또 상태의 뎁스가 깊어지는걸 방지할 수 있습니다.

몹엑스에서는 세가지 개념을 구분하고있습니다.

- State 상태
- Actions 행동
- Derivations 파생

몹엑스를 주로 스프레드시트랑 비교를 하면서 설명을 하는데 사실 스프레드시트를 딱히 많이 써보지않아 비교설명이 불가능할것같아 제외했습니다.

몹엑스에서의 상태는 obsabable 대상이 될 수 있습니다. 즉 상태는 추적의 대상이되고 변경사항이 생겼을때 리액트에서 리렌더링이 발생되도록 합니다.

액션은 몹엑스에서 정의한 상태를 변경할 수 있는 유일한 메서드라고 볼 수 있습니다. 몹엑스의 상태변경은 action 을 통해서 이루어 져야 합니다.

파생은 computed 를 통해 만들 수 있는데 용어를 파생이라고 써서 그러치 class 내에서 get 식별자랑 같이 사용하여 변경된 상태에서의 결과값을 리턴받을때 사용합니다.

이때 computed 에서 계산된 값은 순수해야하고 action 처럼 상태를 변경하는 로직이 포함되서는 안됩니다. computed 에 의해 계산된 값을 자동으로 캐싱되며 계산값이 동일한 결과 값이라면 계산을 다시 실행하지않고 캐싱되어있던 값을 리턴합니다.

몹엑스는 이러한 동작의 상태를 변경하는 원칙으로 단방향 흐름을 사용하고 상태 변경에 따른 영향을 받는 모든 내용들에 대해서 동기적으로 업데이트를 진행합니다.

몹엑스의 데코레이터 사용은 버전에 따라 조금 달라졌는데 6버전 이하에서는 `makeObservable(this)` 가 생성자에서 호출이 필요가 없었지만 6버전부터는 해당 함수의 호출을 사용하는것이 필요합니다. 이는 데코레이터의 구현을 더 간단하고 호환가능하게 만들어 준다고 공식문서에 작성되어있습니다. 근데 어떻게 더 간단하고 호환가능하게 만들어 준다는건지는 아직 잘 모르겠습니다.

데코레이터 지원을 활성화 하기위해서 몇가지 패키지의 설치와 설정이 필요합니다. 타입스크립트를 사용한다면 tsconfig.json 에서 컴파일러 옵션을 사용 `"experimentalDecorators": true` 하고 `"useDefineForClassFields": true` 로 설정해야합니다.

바벨의 설정도 필요한데 패키지설치가 우선되어야합니다.

- @babel/plugin-proposal-class-properties
- @babel/plugin-proposal-decorators

두 패키지의 설치가 끝나면 `.babelrc` 에서 세팅을 해주어야 합니다.

```jsx
{

"plugins": [

["@babel/plugin-proposal-decorators", { "legacy": true }],

["@babel/plugin-proposal-class-properties", { "loose": false }]

// In contrast to MobX 4/5, "loose" must be false!    ^

]

}
```

리액트에서 몹엑스를 적용하기위해서는 두가지 라이브러리가 필요합니다

하난 몹엑스

하난 몹엑스 리액트

몹엑스는 스토어 클래스를 생성하고 해당 클래스내에서 옵저버블, 액션, 컴퓨티드를 사용할 수 있도록 해줍니다. mobx-utils 라이브러리를 사용하면 ayncAction 으로 비동기 처리도 가능합니다. 

몹엑스 자체에 액션 비동기를 처리하는 방법들이 있는데 ayncAction 데코레이터를 사용하는것보다 깔끔하지않고 번거로움이 있어서 해당 데코레이터를 사용한다고 합니다.

일반적으로 몹엑스 사용 예제를 찾으면 대부분 클래스컴포넌트형태로 사용되는게 많습니다. 데코레이터도 일단 제가 알고있고 알아본 내에서는 클래스컴포넌트에서만 사용가능한것같습니다.

함수형 컴포넌트로 몹엑스를 사용하려면 useStore 라는 커스텀 훅을 생성하여 스토어를 사용할 수 있습니다 데코레이터 옵저버는 고차함수형태로 컴포넌트를 감싸서 사용할 수 있습니다.

몹엑스가 채용한 아키텍쳐는 플럭스아키텍쳐를 모방하고 있습니다. 플럭스 아키텍쳐의 기본 구조 또한 어떤 액선을 받아 동기적으로 처리하는 디스패쳐, 스토어, 뷰 로 구성되어있습니다. 여기서 뷰는 리액트에서는 컴포넌트로 볼 수 있습니다.

사용자 즉 뷰 에서 어떤 상호작용이 발생했을때 모든 데이터는 디스패쳐를 통하고 처리됩니다. 

## 참고자료

[Flux | 사용자 인터페이스를 만들기 위한 어플리케이션 아키텍쳐](https://haruair.github.io/flux/docs/overview.html)

[React에서 Mobx 경험기 (Redux와 비교기) | 우아한형제들 기술블로그](https://techblog.woowahan.com/2599/)

[MobX에 대하여 · MobX](https://ko.mobx.js.org/README.html#%EC%86%8C%EA%B0%9C)