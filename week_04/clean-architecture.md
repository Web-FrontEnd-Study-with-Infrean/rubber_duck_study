# 서문

소프트웨어 아키텍처의 규칙이란 프로그램의 구성요소를 정렬하고 조립하는 방법에 관한 규칙이다.

# 01 소개

소프트웨어를 제대로 만들게 되면 소수의 프로그래머만으로 프로그램이 지속적으로 동작하도록 만들 수 있다. 제대로 된 소프트웨어를 만들면 아주 적은 인력만으로도 새로운 기능을 추가하거나 유지보수할 수 있다. 변경은 단순해지고 빠르게 반영할 수 있다. 결함은 적어지고 잦아든다. 최소한의 노력으로 기능과 유연성을 최대화할 수 있다.

그렇지 않은 소프트웨어(단순히 동작하는)는 시스템이 서로 강하게 연관되어 있고 복잡하게 결합되어서, 아주 사소한 변경에도 몇 주가 걸린다.

## 1장 설계와 아키텍처란?

**아키텍처**는 저수준의 세부사항과 분리된 고수준의 무언가를 가리킬때 흔히 사용되는 반면, **설계**는 저수준의 구조 또는 결정사항 등의 의미할 때가 많다. 하지만 모두 소프트웨어 전체 설계의 구성요소고 구분 짓는 경계는 뚜렸하지 않다.

소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는데 투입되는 인력을 최소화하는데 있다.

빨리가는 유일한 방법은 제대로 가는 것이다.

## 5장 객체 지향 프로그래밍

좋은 아키텍처를 만드는 일은 객체 지향 설계 원칙을 이해하고 응용하는 데서 출발한다.

캡슐화 다형성 상속

### 캡슐화

캡슐화를 하면 바깥에서 데이터는 은닉되고, 일부 함수만이 외부에 노출된다. 

### 다형성

플로그인 아키텍처. 

### 의존성 역전

소스코드 의존성의 방향은 반드시 제어흐름을 따르게 된다. 제어흐름은 시스템의 행위에 따라 결정되며, 소스코드 의존성은 제어흐름에 따라 결정된다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4194f509-0d4a-4e8c-9cbe-429a379222b8/의존성역전.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4194f509-0d4a-4e8c-9cbe-429a379222b8/의존성역전.jpeg)

인터페이스를 사이에 두게되면 소스코드 의존성이 제어흐름과는 반대로 흐르게 된다. 이를 의존성 역전이라고 부르게 된다. 다형성을 안전하고 편리하게 제공하는 사실은 소스코드 의존성을 어디에서든 역전시킬 수 있다는 뜻이다. OO 언어로 개발된 시스템을 다루는 소프트웨어 아키텍트는 시스템의 소스코드 의존성 전부에 대해 방향을 결정할 수 있는 절대적인 권한을 갖는다. 즉, 소스코드 의존성이 제어흐름의 방향과 일치되도록 제한되지 않는다.

많은 부분이 인터페이스에 의존하게 됨으로 해당 컴포넌트들은 인터페이스의 플러그인이 되고 배포 독립성까지 얻게 된다.

OO란 다형성을 이용해서 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다. OO를 사용하면 아키텍트는 플러그인 아키텍처를 구성할 수 있고, 이를 통해 고수준의 정책을 포함하는 모듈은 저수준의 세부사항을 포함하는 모듈에 대해 독립성을 보장할 수 있다. 저수준의 세부사항은 중요도가 낮은 플러그인 모듈로 만들 수 있고, 고수준의 정책을 포함하는 모듈과는 독립적으로 개발하고 배포할 수 있다.

# 03 설계 원칙

좋은 소프트웨어 시스템은 깔끔한 코드clean code로부터 시작한다. 하지만 깔끔한 코드를 사용하더라도 아키텍처를 엉망으로 만들 수 있다. 깔끔한 코드로 좋은 아키텍처를 정의하는 원칙이 SOLID다.

SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다. 여기서 클래스는 단순히 함수와 데이터를 결합한 집합을 가리킨다.

SOLID 원칙의 목적은 중간 수준의 소프트웨어 구조가 아래와 같도록 만드는데 있다.

- 변경에 유연하다.
- 이해하기 쉽다.
- 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 된다.

## 7장 SRP: 단일 책임 원칙 (Single Responsibility Principle)

각 소프트웨어 모듈은 변경의 이유가 하나, 단 하나여야만 한다.

"하나의 모듈은 하나의 엑터에 대해서만 책임져야 한다."로 바꿔 말할 수 있다.

모듈은 단순히 함수와 데이터 구조로 구성된 응집된 집합이다. '응집된'이라는 단어가 SRP를 암시한다. 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성이다.

- 서로 다른 액터가 의존하는 코드는 서로 분리해야한다.
- 여러 매서드들이 서로 다른 액터를 책임진다면 변합이 발생할 가능성이 높다. 많은 사람들이 서로 다른 목적으로 동일한 소스 파일을 변경하는 경우 문제가 발생하므로 서로 다른 액터를 뒷받침하는 코드는 분리해야한다.

단일 책임 원칙은 매서드와 클래스 수준의 원칙이다. 이보다 상위 수준인 컴포넌트 수준에서는 공통 폐쇄 원칙(Common Closure Principle)이 된다.

## 8장 OCP: 개방-폐쇄 원칙 (Open-Closed Principle)

기존 코드를 수정하기 보다는 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다.

소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다.

다시말해 소프트웨어 개체의 행위는 확장할 수 있어야 하지만, 이때 산출물을 변경해서는 안된다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ece4eb9e-077f-4034-8510-7d3e289cd221/ocp2.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/ece4eb9e-077f-4034-8510-7d3e289cd221/ocp2.jpeg)

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4073253b-9273-4c5d-a410-b711d83a487a/ocp.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/4073253b-9273-4c5d-a410-b711d83a487a/ocp.jpeg)

화살표는 소스코드 의존성을 나타낸다.  여기에서 주목해야 할 점은 이중선은 화살표와 오직 한 방향으로만 교차한다는 사실이다. 이는 모든 컴포넌트 관계는 단방향으로 이루어진다는 뜻이다. 이들 화살표는 보호하려는 컴포넌트를 향하도록 그려진다. A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야 한다. 위의 그림에서 Presenter에서 발생한 변경으로부터 Controller를 보호하고자 한다. 그리고 View에서 발생한 변경으로부터 Presenter를 보호하고자 한다. Interactor는 OCP를 가장 잘 준수할 수 있는 곳에 위치한다. Database, Controller, Presenter, View에서 발생한 어떤 변경도 Interactor에 영향을 주지 않는다.

Interactor가 이처럼 특별한 위치를 차지하는 이유는 업무 규칙(가장 높은 수준의 정책)을 포함하기 때문이다. Interactor는 가장 높은 수준의 개념이며, 따라서 최고의 보호를 받는다. View는 가장 낮은 수준의 개념 중 하나이며, 따라서 거의 보호를 받지 못한다. 

컴포넌트 계층구조를 이와같이 조직화하면 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.

### 방향성 제어

다소 복잡하지만 컴포넌트 간 의존성이 제대로 된 방향으로 향하고 있음을 확실히 보여준다.

예를들어 FinancialDataGateway 인터페이스는 FinancialReportGenerator와 FinancialDataMapper 사이에 위치하는데, 이는 의존성을 역전시키기 위해서다. FinancialDataGateway 인터페이스가 없었다면, 의존성이 Interactor 컴포넌트에서 Database 컴포넌트로 바로 향하게 된다. FinaicalReportPresenter 인터페이스와 2개의 View 인터페이스도 같은 목적을 가진다.

### 정보 은닉

FinancialReportRequester 인터페이스는 방향성 제어와는 다른 목적을 가진다. 이 인터페이스는 FinancialReportController가 Interactor 내부에 대해 너무 많이 알지 못하도록 막기 위해서 존재한다. 만약 이 인터페이스가 없었다면, Controller는 FinancialEntities에 대해 추이 종속성(transitive dependency)을 가지게 된다.

추이 종속성을 가지게 되면, 소프트웨어 엔티티는 '자신이 직접 사용하지 않는 요소에는 절대로 의존해서는 안된다'는 소프트웨어 원칙을 위반하게 된다.

다시 말해, Controller에서 발생한 변경으로부터 Interactor를 보호하는 일의 우선순위가 가장 높지만, 반대로 Interactor에서 발생한 변경으로부터 Controller도 보호하기 위해 Interactor 내부를 은닉한다.

### 결론

OCP의 목표는 시스템을 확장하기 쉬운 동시에 변경으로 인해 시스템이 너무 많이 영향을 받지 않도록 하는데 있다. 이러한 목표를 달성하려면 시스템을 컴포넌트 단위로 분리하고, 저수준 컴포넌트에서 발생한 변경으로 부터 고수준 컴포넌트를 보호할 수 있는 형태의 의존성 계층구조가 만들어져야 한다.

## 9장 LSP: 리스코프 치환 원칙 (Liskov Substitution Principle)

상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 지켜야 한다.

### LSP와 아키텍처

객체 지향의 초창기에는 LSP는 상속을 사용하도록 가이드하는 방법 정도로 간주되었다. 하지만 시간이 지나면서 LSP는 인터페이스와 구현체에도 적용되는 더 광범위한 소프트웨어 설계 원칙으로 변모해왔다.

잘 정의된 인터페이스와 그 인터페이스의 구현체끼리의 상호 치환이 가능해야한다.

## 10장 ISP: 인터페이스 분리 원칙 (Interface Segregation Principle)

소프트웨어 설계자는 사용하지 않는 것에 의존하지 않아야 한다.

### ISP와 아키텍처

필요 이상으로 많은 걸 포함하는 모듈에 의존하는 것은 해로운 일이다. 소스코드 의존성의 경우 이는 분명한 사실인데, 불필요한 재컴파일과 재배포를 강제하기 때문이다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/23c46d2a-c58b-4ac7-9a9a-05fec8266662/10-3.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/23c46d2a-c58b-4ac7-9a9a-05fec8266662/10-3.jpeg)

F에서는 불필요한 기능, 따라서 S와는 전혀 관계없는 기능이 D에 포함된다고 가정하자. 그 기능이 D 내부에서 변경이 발생하면, F를 재배포해야 할 수 있고, 따라서 S까지 재배포해야 할지 모른다. 더 심각한 문제는 D 내부의 기능 중 F와 S에서 불필요한 그 기능에 문제가 발생해도 F와 S에 영향을 준다는 사실이다.

## 11장 DIP: 의존성 역전 원칙 (Dependency Inversion Principle)

고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대로 의존해서는 안된다. 대신 세부사항이 정책에 의존해야 한다.

DIP에서 말하는 유연성이 극대화된 시스템이란 소스코드 의존성이 추상abstration에 의존하며 구체concretion에는 의존하지 않는 시스템이다. 

DIP를 논할 때 운영제체나 플랫폼 같이 안정성이 보장된 환경에 대해서는 무시하는 편이다. 우리는 이들 환경에 대한 의존성을 용납하는데, 변경되지 않는다면 의존할 수 있다는 사실을 이미 알고 있기 떄문이다.

우리가 의존하지 않도록 피하고자 하는 것은 바로 변동성이 큰 구체적인 요소이다.

### 안정된 추상화

추상 인터페이스에 변경이 생기면 이를 구체화한 구현체들도 따라서 수정해야 한다. 반대로 구체적인 구현체에 변경이 생기더라도 그 구현체가 구현하는 인터페이스는 변경될 필요가 없다.

안정된 소프트웨어 아키텍처란 변동성이 큰 구현체에 의존하는 일을 지양하고 안전된 추상 인터페이스를 선호하는 아미텍처이다.

- **변동성이 큰 구체 클래스를 참조하지 말아라.** 대신 추상 인터페이스를 참조해라.
- **변동성이 큰 구체 클래스로부터 파생하지 말아라.**
- **구체함수를 오버라이드 하지 말아라.** 대체로 구체 함수는 소스코드 의존성을 필요로한다. 그러면 그 의존성을 상속하게 된다. 차라리 추상 함수로 선언하고 구현체들에서 각자의 용도에 맞게 구현해야 한다.
- **구첵적이고 변동성이 크다면 절대로 그 이름을 언급하지 말아라.**

제어흐름은 소스코드 의존성과는 정반대 방향으로 곡선을 가로지른다. 다시 말해 소스코드 의존성은 제어흐름과는 반대 방향으로 역전된다. 이러한 이유로 이 원칙을 의존성 역전이라고 부른다.

# 04 컴포넌트 원칙

SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해준다. 큰 빌딩과 마찬가지로 대규모 소프트웨어 시스템은 작은 컴포넌트들로 만들어진다.

## 12장 컴포넌트

컴포넌트는 배포 단위다. 컴포넌트는 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위다.

## 13장 컴포넌트 응집도

어떤 클래스를 어느 컴포넌트에 포함시켜야 할까? 컴포넌트 응집도와 관련된 세 가지 윈칙이 있다.

- REP: 재사용/릴리스 등가 원칙 (Reuse/Release Equivalence Principle)

    재사용 단위는 릴리스 단위와 같다. 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻한다. 단순히 뒤죽박죽 임의로 선택된 클래스와 모듈로 구성되어서는 안된다. 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다.

- CCP: 공통 폐쇄 원칙 (Common Closure Principle)

    동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.

    이 원칙은 단일 책임 원칙을 컴포넌트 관점에서 다시 쓴 것이다.

    대다수의 애플리케이션에 유지보수성은 재사용성보다 훨씬 중요하다. 애플리케이션에서 코드가 반드시 변경되어야 한다면, 이러한 변경이 여러 컴포넌트 도처에 분산되어 발생하기보다는, 차라리 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.

    CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권한다. 물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야 한다.

- CRP: 공통 재사용 원칙 (Common Reuse Principle)

    컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라. (필요하지 않는 것에 의존하지 말라.)

    crp에서는 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말한다.

    crp는 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말해준다. 어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에는 의존성이 생겨난다. 어쩌면 사용하는 컴포넌트가 사용된느 컴포넌트에서 단 하나의 클래스만 사용할 수도 있다. 그렇다고 해서 의존성은 조금도 약해지지 않는다. 사용하는 컴포넌트는 사용되는 컴포넌트에 여전히 의존한다. 따라서 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다. 즉 CRP는 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안된다고 말한다.

    CRP는 인터페이스 분리 원칙의 포괄적인 버전이다. ISP는 사용하지 않는 메서드가 있는 클래스에 의존하지 말라고 조언한다. CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 조언한다.

### 컴포넌트 응집도에 대한 균형 다이어그램

위의 세 원칙은 서로 상충된다. REP와 CCP는 포함 원칙이다. 두 원칙은 컴포넌트를 더욱 크게 만든다. CRP는 배제 원칙이며, 컴포넌트를 더욱 작게 든다. 

다음 그림은 균형 다이어그램으로, 응집도에 관한 세 원칙이 서로 어떻게 상호작용하는지 보여준다.

![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d8705208-ad8b-4c60-8a0c-0c2fa312bd84/13-1.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d8705208-ad8b-4c60-8a0c-0c2fa312bd84/13-1.jpeg)

REP와 CRP에만 중점을 두면, 사소한 변경이 생겼을 때 너무 많은 컴포넌트에 영향을 미친다. 반대로 CCP와 REP에만 과도하게 집중하면 불필요한 릴리스가 너무 빈번해진다.

이 균형 삼각형에서 개발팀이 현재 관심을 기울이는 부분을 충족시키는 위치를 찾아야 하며, 또한 시간이 흐르면서 개발팀이 주의를 기울이는 부분 역시 변한다는 사실도 이해하고 있어야 한다. 예를 들어 프로젝트 초기에는 CCP가 REP보다 훨씬 중요한데, 개발 가능성이 재사용성보다 더욱 중요하기 때문이다.

일반적으로 프로젝트는 삼각형의 오른쪽에서 시작하는 편이며, 이때는 오직 재사용성만 희생하면 된다. 프로젝트가 성숙하고, 그 프로젝트로부터 파생된 또 다른 프로젝트가 시작되면, 프로젝트는 삼각형에서 점차 왼쪽으로 이동해 간다.

클래스들을 묶어서 컴포넌트를 만들지를 결정할 때, 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야 한다.

## 14장 컴포넌트 결합

컴포넌트 사이의 관계를 설명한다. 

- ADP: 의존성 비순환 원칙

    컴포넌트 의손성 그래프에 순환이 있어서는 안된다.

    의존성 역전 원칙(DIP)를 사용한다. 인터페이스를 사용해 의존성을 역전시킴으로써 순환을 끊는다.

- SDP: 안정된 의존성 원칙

    안정성의 방향으로 의존하라. 

    변경이 쉽지 않는 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 절대로 안 된다. 한 번 의존하게 되면 변동성이 큰 컴포넌트도 결국 변경이 어려워진다. 컴포넌트 안쪽으로 들어오는 의존성이 많아지면 안정적이라고 볼 수 있다. 사소한 변경이라도 의존하는 모든 컴포넌트를 만족시키면서 변경하려면 상당한 노력이 들기 때문이다.

- SAP: 안정된 추상화 원칙

    컴포넌트는 안정된 정도만큼만 추상화되어야 한다.

    시스템에는 자주 변경해서는 절대로 안되는 소프트웨어도 있다. 고수준 아키텍처나 정책 결정과 관련된 소프트웨어가 그 예다. 시스템에서는 고수준 정책을 캡슐화하는 소프트웨어는 반드시 안정된 컴포넌트에 위치해야 한다. 불안정한 컴포넌트는 반드시 변동성이 큰 소프트웨어, 즉 쉽고 빠르게 변경할 수 있는 소프트웨어만을 포함해야 한다.

    하지만 고수준 정책을 안정된 컴포넌트에 위치시키면, 그 정책을 포함하는 소스코드는 수정하기가 어려워진다. 이로 인해 시스템 전체 아키텍처가 유연성을 잃는다. 컴포넌트가 최고로 안정된 상태이면서도 동시에 변경에 충분히 대응하려면 OCP를 적용하면 된다. OCP는 클래스를 수정하지 않고도 확장이 충분히 가능할 정도로 클래스를 유연하게 만들 수 있을 뿐 아니라 바람직한 방식이다. (추상 클래스)

# 05 아키텍처

## 22장 클린 아키텍처

시스템 아키텍처와 관련된 여러 서적에서 세부적인 면에서는 다소 차이가 있더라도 그 내용은 상당히 비슷하다. 이들의 목표는 모두 같은데, 바로 관심사의 분리다. 이들은 모두 소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성할 수 있다. 각 아키텍처는 최소한 업무 규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함한다.

- 프레임워크 독립성. 아키텍처는 다양한 기능의 라이브러리를 제공하는 프레임워크의 존재 여부에 의존하지 않는다.
- 테스트 용이성. 업무 규칙은 UI등 외부 요소가 없이도 테스트할 수 있다.
- UI 독립성. 시스템의 나머지 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있다.

    ![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3800864d-6c1b-4a2a-b530-ec75fc54f316/22-1.jpeg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3800864d-6c1b-4a2a-b530-ec75fc54f316/22-1.jpeg)

### 의존성 규칙

아키텍처가 동작하도록 하는 가장 중요한 규칙은 의존성 규칙이다.

소스코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.

### 엔티티

엔티티는 전사적인 핵심 엄무 규칙을 캡슐화한다. 운영 관점에서 특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안된다.

# 06 세부사항

## 34장 빠져 있는 장

더 나은 소프트웨어를 설계하는 것은 올바르게 정의된 경계, 명확한 책임, 그리고 통제된 의존성을 가진 클래스와 컴포넌트이다.
