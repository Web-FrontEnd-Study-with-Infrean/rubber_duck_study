# 알고리듬, 효율성, 기초 자료구조

## 1. 계기

- 알고리듬 정리
- 알고리듬과 자료구조 강의

## 2. 알고리듬의 정의

어떤 부류의 문제를 해결하는 컴퓨터로 구현 가능한 명령어들

### 훌륭한 알고리듬의 조건

- 입력과 출력이 명확
- 알고리듬의 각 단계가 명확
- 유한한 시간 안에 결과가 나와야함
- 어떤 프로그래밍 언어로도 구현할 수 있어야함 (특정 언어나 하드웨어에서 구현 못 하는 경우 NG)
- 같은 문제를 푸는 다양한 방법 중에 효율적일 것


## 효율적인 알고리듬

알고리듬의 각 단계가 시간이 얼마나 걸리는지에 따라 시간 복잡도, 메모리를 얼마나 필요로 하는지에 따라
 공간 복잡도를 얼마나 복잡한지에 따라 공간 복잡도라는 개념으로 알고리듬의 성능을 측정할 수 있음

### 알고리듬의 성능 표기 : 빅오 표기법의 경우

- 대략적으로 알고리듬의 성능을 분류하기 위한 표기법
- 입력 데이터 N이 증가할 때 실행 복잡도는 어떻게 증가하는지를 함수를 사용해서 표기함
- Order of the function -> 대략 그 함수 정도

O(1) < O(logn) < O(n) < O(nlogn) < O(n2^2) < O(n!)

### 실무에서의 허용 범위

- 교과서에서 다항함수까지 OK, 지수함수 NG
- (강의에서도, 개인적인 경험에서도) 대략 O(n^2)까지, 반복문 두 개를 중첩해서 쓰는 정도까지는 OK
- O(n^3) 이상인 경우 조금 문제 의식을 느낌

## 기초 자료 구조에서의 시간 복잡도

찾으려는 데이터가 앞 쪽에 있는 경우(최선의 경우), 뒤 쪽에 있는 경우(최악의 경우)도 있을 수 있지만, 평균과 최악의 경우만을 생각해보면 다음과 같음

### 배열

- 평균적으로 검색, 삽입, 삭제 O(n)
- 최악의 경우에도 동일
- 삽입과 삭제의 경우, 데이터를 당기거나 밀 필 요가 없으면 O(1)이 될 수 있음

### 스택, 큐

- 평균적으로 검색만 O(n)이고 삽입과 삭제는 O(1)
- 최악의 경우도 동일

### 연결리스트

- 평균적으로 검색만 O(n)이고 삽입과 삭제는 O(1)
- 최악의 경우도 동일

### 해시 테이블. 해쉬 맵

- 평균적으로 검색, 삽입, 삭제 모두 O(1)로 매우 빠름
- 단, 충돌이 일어나는 최악의 경우 검색, 삽입, 삭제 O(n)이 될 수 있음

## 정리

- 알고리듬이란 어떤 문제를 효율적으로 해결하기 위한 명령어들
- 어떤 얼마나 효율적인지, 입력값 N이 증가할 때, 알고리듬에 걸리는 시간/공간 복잡도가 어떻게 증가하는지를 빅오 표기법을 통해 표현할 수 있음
- 기초 자료 구조들은 검색, 삽입, 삭제 시 평균적으로 O(1)이나 O(n)의 시간 복잡도를 가짐